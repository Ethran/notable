package com.ethran.notable.editor.utils

import android.graphics.Rect
import android.view.View
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.composed
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.input.nestedscroll.NestedScrollConnection
import androidx.compose.ui.input.nestedscroll.NestedScrollSource
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.unit.Velocity
import com.ethran.notable.TAG
import com.ethran.notable.data.datastore.AppSettings
import com.ethran.notable.data.datastore.GlobalAppSettings
import com.ethran.notable.utils.logCallStack
import com.onyx.android.sdk.api.device.epd.EpdController
import com.onyx.android.sdk.api.device.epd.EpdController.SCHEME_NORMAL
import com.onyx.android.sdk.api.device.epd.EpdController.SCHEME_SCRIBBLE
import com.onyx.android.sdk.api.device.epd.UpdateMode
import com.onyx.android.sdk.api.device.epd.UpdateOption
import com.onyx.android.sdk.device.Device
import com.onyx.android.sdk.pen.TouchHelper
import io.shipbook.shipbooksdk.Log
import io.shipbook.shipbooksdk.ShipBook
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

private val einkLogger = ShipBook.getLogger("einkHelper")

/**
 * ONYX EPD REFRESH MODES GUIDE (Generated by AI, better then nothing)
 * ============================================
 *
 * ### 1. Update Modes (Quality â†” Speed Tradeoff)
 * These control the balance between refresh speed and display quality:
 *
 * | Mode         | Description                                       |
 * |--------------|---------------------------------------------------|
 * | `GC`         | Full refresh (Best quality, slowest, no ghosting) |
 * | `GU`         | Grayscale update (Partial refresh, preserves tone)|
 * | `DU`         | Direct update (Faster, partial, moderate quality) |
 * | `ANIMATION`  | Smooth animation updates (some ghosting possible) |
 * | `A2`         | Fastest update (Lowest quality, minimal latency)  |
 * | `DEEP_GC`    | Deep clean refresh (Best for text rendering)      |
 *
 * ### 2. Display Schemes (System-Wide Presets)
 * Affect the global system behavior:
 *
 * | Scheme                        | Description                          |
 * |-------------------------------|--------------------------------------|
 * | `SCHEME_NORMAL`              | Default balanced e-ink mode          |
 * | `SCHEME_KEYBOARD`           | Optimized for keyboard input         |
 * | `SCHEME_SCRIBBLE`           | Best for handwriting/stylus input    |
 * | `SCHEME_APPLICATION_ANIMATION` | App-specific animation optimization |
 * | `SCHEME_SYSTEM_ANIMATION`   | System-wide animation optimization   |
 *
 * ### 3. Special Functions (System-Level Tools)
 *
 * | Function                  | Description                                      |
 * |---------------------------|--------------------------------------------------|
 * | `applyGCOnce()`           | Force one full-screen GC refresh                |
 * | `repaintEveryThing()`     | Repaints the entire screen with current mode    |
 * | `fillWhiteOnWakeup()`     | Clears residual ghosting on wake                |
 * | `useGCForNewSurface()`    | Forces GC when new surfaces appear              |
 * | `setEpdTurbo(int)`        | Adjusts refresh speed (0 = slow, 100 = fastest) |
 *
 * ### 4. View-Specific Controls
 * Fine-grained control per view:
 *
 * | Function                        | Description                                |
 * |----------------------------------|--------------------------------------------|
 * | `setViewDefaultUpdateMode()`    | Sets default update mode for a specific view |
 * | `resetViewUpdateMode()`         | Resets view update mode to system default   |
 * | `disableA2ForSpecificView()`    | Disables A2 mode for that view              |
 * | `handwritingRepaint()`          | Optimized refresh for handwriting regions   |
 *
 * ### 5. Waveform Controls (Advanced Tuning)
 *
 * | Function          | Description                            |
 * |-------------------|----------------------------------------|
 * | `enableRegal()`   | Enables Regal waveform for less ghosting |
 * | `disableRegal()`  | Disables Regal waveform                 |
 * | `setTrigger()`    | Sets waveform trigger count             |
 * | `byPass()`        | Skips scheduled waveform updates        |
 *
 * ### 6. Visual Enhancements
 * Adjust display contrast and rendering:
 *
 * | Function                        | Description                                  |
 * |----------------------------------|----------------------------------------------|
 * | `applyGammaCorrection()`        | Adjusts gamma curve for contrast             |
 * | `applyMonoLevel()`              | Controls monochrome intensity                |
 * | `applyColorFilter()`            | Adjusts color tones (for color e-ink only)   |
 * | `setWebViewContrastOptimize()`  | Enhances contrast in WebViews                |
 *
 * ### Common Usage Patterns:
 *
 * // For animations or video playback:
 * EpdController.setDisplayScheme(SCHEME_APPLICATION_ANIMATION)
 * EpdController.setViewDefaultUpdateMode(view, ANIMATION)
 *
 * // For standard reading mode:
 * EpdController.setDisplayScheme(SCHEME_NORMAL)
 * EpdController.applyGCOnce() // To remove ghosting
 *
 * // For handwriting or drawing apps:
 * EpdController.setDisplayScheme(SCHEME_SCRIBBLE)
 * EpdController.handwritingRepaint(inkView, dirtyRect)
 *
 * // To reset view to default behavior:
 * EpdController.resetViewUpdateMode(view)
 * EpdController.setDisplayScheme(SCHEME_NORMAL)
 */


/**
 * Toggles animation-optimized mode for smoother UI interactions.
 *
 * @param isAnimationMode true to enable fast/animation mode, false for normal refresh
 */
fun setAnimationMode(isAnimationMode: Boolean) {
// reference:
// https://github.com/onyx-intl/OnyxAndroidDemo/blob/d3a1ffd3af231fe4de60a2a0da692c17cb35ce31/app/OnyxPenDemo/src/main/java/com/onyx/android/eink/pen/demo/ui/PenDemoActivity.java#L500
    if (isAnimationMode) {
        EpdController.applyTransientUpdate(UpdateMode.ANIMATION_X)
        einkLogger.d("Animation mode enabled")
    } else {
        EpdController.clearTransientUpdate(true)
        einkLogger.d("Animation mode disabled")
    }
}

fun setRecommendedMode() {
    EpdController.setAppScopeRefreshMode(UpdateOption.NORMAL)
    einkLogger.d("Changed to NORMAL mode")
}

fun isRecommendedRefreshMode(): Boolean {
    val updateOption: UpdateOption = Device.currentDevice().appScopeRefreshMode
    return updateOption == UpdateOption.NORMAL || updateOption == UpdateOption.REGAL
}

fun getCurRefreshModeString(): String {
    return (Device.currentDevice().appScopeRefreshMode).toString()
}

suspend fun waitForEpdRefresh(updateOption: UpdateOption = Device.currentDevice().appScopeRefreshMode) {
    einkLogger.d("Waiting for screen, Update mode: $updateOption")
//        Device.currentDevice().waitForUpdateFinished()
    // depending on device, it may take different amount of time to
    // refresh the screen. So for example, when closing menus, we
    // need to wait before we freeze screen.

    // Onyx library might change
    @Suppress("REDUNDANT_ELSE_IN_WHEN")
    when (updateOption) {
        UpdateOption.NORMAL -> {
            // HD mode
            delay(190) // On my device ~160 is the minimal delay
        }

        UpdateOption.REGAL -> {
            // regal mode
            delay(180) // On my device ~150 is the minimal delay
        }

        UpdateOption.FAST -> {
            //ultra fast, fast, balanced
            delay(20) // 5ms is problematic sometimes on balanced mode.
        }

        UpdateOption.FAST_X -> {
            // no idea what it is
            delay(4) // Minimal delay
        }

        UpdateOption.FAST_QUALITY -> {
            // no idea what it is
            delay(15)
        }

        else -> {
            // Default fallback
            Log.e(TAG, "Unknown refresh mode: $updateOption")
            delay(10)
        }
    }
}

/**
 * Attempts to set the refresh mode for a view using the Onyx EPDController.
 * Catches and logs exceptions to prevent crashes on unsupported devices or update modes.
 * Returns true if successful, false otherwise.
 * This is necessary because the Onyx library is unstable and unreliable.
 */
private fun tryToSetRefreshMode(view: View, mode: UpdateMode): Boolean {
    return try {
        EpdController.setViewDefaultUpdateMode(view, mode)
        einkLogger.d("Set update mode $mode")
        true
    } catch (e: NullPointerException) {
        einkLogger.d("Device does not support update mode $mode (NullPointerException): ${e.message}")
        false
    } catch (e: IllegalArgumentException) {
        einkLogger.d("Device does not support update mode $mode (IllegalArgumentException): ${e.message}")
        false
    } catch (e: Exception) {
        einkLogger.e("Unexpected error when setting update mode $mode: ${e.message}", e)
        false
    }
}

fun onSurfaceInit(view: View) {
    einkLogger.v("onSurfaceInit, (${view.left}, ${view.top} - ${view.right}, ${view.bottom})")
    if(!tryToSetRefreshMode(view, UpdateMode.HAND_WRITING_REPAINT_MODE))
        tryToSetRefreshMode(view, UpdateMode.REGAL)
    EpdController.enablePost(1)
}

fun onSurfaceChanged(view: View) {
    EpdController.enablePost(view, 1)

}


fun onSurfaceDestroy(view: View, touchHelper: TouchHelper) {
    einkLogger.v("onSurfaceDestroy, (${view.left}, ${view.top} - ${view.right}, ${view.bottom})")
    touchHelper.setRawDrawingEnabled(false)
}


fun setupSurface(view: View, touchHelper: TouchHelper, toolbarHeight: Int) {
    // Takes at least 50ms on Note 4c,
    // and I don't think that we need it immediately
    einkLogger.i("Setup editable surface")
    touchHelper.debugLog(false)
    touchHelper.setRawDrawingEnabled(false)
    touchHelper.closeRawDrawing()

    // Store view dimensions locally before using in Rect
    val viewWidth = view.width
    val viewHeight = view.height

    // Determine the exclusion area based on toolbar position
    val excludeRect: Rect =
        if (GlobalAppSettings.current.toolbarPosition == AppSettings.Position.Top) {
            Rect(0, 0, viewWidth, toolbarHeight)
        } else {
            Rect(0, viewHeight - toolbarHeight, viewWidth, viewHeight)
        }

    val limitRect =
        if (GlobalAppSettings.current.toolbarPosition == AppSettings.Position.Top)
            Rect(0, toolbarHeight, viewWidth, viewHeight)
        else
            Rect(0, 0, viewWidth, viewHeight - toolbarHeight)

    touchHelper.setLimitRect(mutableListOf(limitRect)).setExcludeRect(listOf(excludeRect))
        .openRawDrawing()

    touchHelper.setRawDrawingEnabled(true)
    einkLogger.i("Setup editable surface completed")

}

fun prepareForPartialUpdate(view: View, touchHelper: TouchHelper) {
    EpdController.setDisplayScheme(SCHEME_SCRIBBLE)
//    EpdController.useFastScheme() // the same as above
    EpdController.enableA2ForSpecificView(view)
//    EpdController.enablePost(view, 1)
    EpdController.setEpdTurbo(100)
    //exit of drawing mode
    touchHelper.isRawDrawingRenderEnabled = false
    touchHelper.isRawDrawingRenderEnabled = true
}

fun refreshScreenRegion(view: View, dirtyRect: Rect) {
    if (!view.isAttachedToWindow) {
        einkLogger.e("View is not attached to window")
        logCallStack("refreshScreenRegion")
    }
    EpdController.refreshScreenRegion(
        view,
        dirtyRect.left,
        dirtyRect.top,
        dirtyRect.width(),
        dirtyRect.height(),
        UpdateMode.ANIMATION_MONO
    )
//    EpdController.handwritingRepaint(view, dirtyRect)
}

fun restoreDefaults(view: View) {
//    EpdController.resetViewUpdateMode(view)
    EpdController.setDisplayScheme(SCHEME_NORMAL)

}


fun partialRefreshRegionOnce(view: View, dirtyRect: Rect, touchHelper: TouchHelper) {
    refreshScreenRegion(view, dirtyRect)
    resetScreenFreeze(touchHelper)
    // we need to wait before refreshing, as onyx library has its own buffer that needs to be updated. Otherwise we will refresh to correct, then  incorrect and then correct state.
//    delay(100)
//    resetScreenFreeze(touchHelper)
}

fun resetScreenFreeze(touchHelper: TouchHelper, view: View? = null) {
    touchHelper.isRawDrawingRenderEnabled = false
    touchHelper.isRawDrawingRenderEnabled = true
//    setRawDrawingEnabled(false)
//    setRawDrawingEnabled(true)
}

//    Device.currentDevice().invalidate(this@DrawCanvas, UpdateMode.ANIMATION_MONO);
//    EpdController.refreshScreen(view, UpdateMode.ANIMATION_MONO)
//    EpdController.setEpdTurbo(100)
//    EpdController.clearTransientUpdate(true)
//    EpdController.repaintEveryThing()
//    EpdController.setScreenHandWritingPenState(view, EpdPenManager.PEN_PAUSE)
//    EpdController.setScreenHandWritingPenState(view, EpdPenManager.PEN_DRAWING)


/**
 * Automatically toggles eâ€‘ink animation mode when the attached subtree scrolls.
 * Works with any Compose scrollable that supports nested scroll (Lazy* and scrollable()).
 *
 * - Turns on immediately when any scroll/drag/fling starts.
 * - Turns off after [debounceOffMillis] from the end of drag/fling.
 */
fun Modifier.autoEInkAnimationOnScroll(
    debounceOffMillis: Long = 500,
    setMode: (Boolean) -> Unit = ::setAnimationMode
): Modifier = composed {
    val scope = rememberCoroutineScope()
    var offJob: Job? by remember { mutableStateOf(null) }

    fun turnOn() {
        offJob?.cancel()
        setMode(true)
    }

    fun scheduleOff() {
        offJob?.cancel()
        offJob = scope.launch {
            delay(debounceOffMillis)
            setMode(false)
        }
    }

    val connection = remember(debounceOffMillis, setMode) {
        object : NestedScrollConnection {
            // Any pre-scroll (user drag) -> ON
            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {
                if (available != Offset.Zero) turnOn()
                return Offset.Zero
            }

            // Any post-scroll (child consumed) -> ON
            override fun onPostScroll(
                consumed: Offset,
                available: Offset,
                source: NestedScrollSource
            ): Offset {
                if (consumed != Offset.Zero) {
                    turnOn()
                } else if (source == NestedScrollSource.UserInput && available == Offset.Zero) {
                    // Likely drag end without fling -> schedule OFF
                    scheduleOff()
                }
                return Offset.Zero
            }

            // Fling start -> ON
            override suspend fun onPreFling(available: Velocity): Velocity {
                turnOn()
                return Velocity.Zero
            }

            // Fling finished -> schedule OFF
            override suspend fun onPostFling(consumed: Velocity, available: Velocity): Velocity {
                scheduleOff()
                return Velocity.Zero
            }
        }
    }

    DisposableEffect(Unit) {
        onDispose { offJob?.cancel() }
    }

    this.nestedScroll(connection)
}